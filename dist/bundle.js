/*! For license information please see bundle.js.LICENSE.txt */
(()=>{var t={320:(t,e)=>{"use strict";function r(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function n(t){if("boolean"!=typeof t)throw new Error(`Expected boolean, not ${t}`)}function o(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function i(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");r(t.outputLen),r(t.blockLen)}function s(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function a(t,e){o(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}Object.defineProperty(e,"__esModule",{value:!0}),e.output=e.exists=e.hash=e.bytes=e.bool=e.number=void 0,e.number=r,e.bool=n,e.bytes=o,e.hash=i,e.exists=s,e.output=a;const c={number:r,bool:n,bytes:o,hash:i,exists:s,output:a};e.default=c},505:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.SHA2=void 0;const n=r(320),o=r(89);class i extends o.Hash{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=(0,o.createView)(this.buffer)}update(t){n.default.exists(this);const{view:e,buffer:r,blockLen:i}=this,s=(t=(0,o.toBytes)(t)).length;for(let n=0;n<s;){const a=Math.min(i-this.pos,s-n);if(a!==i)r.set(t.subarray(n,n+a),this.pos),this.pos+=a,n+=a,this.pos===i&&(this.process(e,0),this.pos=0);else{const e=(0,o.createView)(t);for(;i<=s-n;n+=i)this.process(e,n)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){n.default.exists(this),n.default.output(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:i,isLE:s}=this;let{pos:a}=this;e[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>i-a&&(this.process(r,0),a=0);for(let t=a;t<i;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),a=Number(r&i),c=n?4:0,u=n?0:4;t.setUint32(e+c,s,n),t.setUint32(e+u,a,n)}(r,i-8,BigInt(8*this.length),s),this.process(r,0);const c=(0,o.createView)(t),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=u/4,f=this.get();if(h>f.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<h;t++)c.setUint32(4*t,f[t],s)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:o,destroyed:i,pos:s}=this;return t.length=n,t.pos=s,t.finished=o,t.destroyed=i,n%e&&t.buffer.set(r),t}}e.SHA2=i},945:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.crypto=void 0,e.crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},569:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.hmac=e.HMAC=void 0;const n=r(320),o=r(89);class i extends o.Hash{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,n.default.hash(t);const r=(0,o.toBytes)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(r.length>i?t.create().update(r).digest():r);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),s.fill(0)}update(t){return n.default.exists(this),this.iHash.update(t),this}digestInto(t){n.default.exists(this),n.default.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=n,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}e.HMAC=i,e.hmac=(t,e,r)=>new i(t,e).update(r).digest(),e.hmac.create=(t,e)=>new i(t,e)},61:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sha224=e.sha256=void 0;const n=r(505),o=r(89),i=(t,e,r)=>t&e^t&r^e&r,s=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),a=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),c=new Uint32Array(64);class u extends n.SHA2{constructor(){super(64,32,8,!1),this.A=0|a[0],this.B=0|a[1],this.C=0|a[2],this.D=0|a[3],this.E=0|a[4],this.F=0|a[5],this.G=0|a[6],this.H=0|a[7]}get(){const{A:t,B:e,C:r,D:n,E:o,F:i,G:s,H:a}=this;return[t,e,r,n,o,i,s,a]}set(t,e,r,n,o,i,s,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)c[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=c[t-15],r=c[t-2],n=(0,o.rotr)(e,7)^(0,o.rotr)(e,18)^e>>>3,i=(0,o.rotr)(r,17)^(0,o.rotr)(r,19)^r>>>10;c[t]=i+c[t-7]+n+c[t-16]|0}let{A:r,B:n,C:a,D:u,E:h,F:f,G:l,H:d}=this;for(let t=0;t<64;t++){const e=d+((0,o.rotr)(h,6)^(0,o.rotr)(h,11)^(0,o.rotr)(h,25))+((y=h)&f^~y&l)+s[t]+c[t]|0,p=((0,o.rotr)(r,2)^(0,o.rotr)(r,13)^(0,o.rotr)(r,22))+i(r,n,a)|0;d=l,l=f,f=h,h=u+e|0,u=a,a=n,n=r,r=e+p|0}var y;r=r+this.A|0,n=n+this.B|0,a=a+this.C|0,u=u+this.D|0,h=h+this.E|0,f=f+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(r,n,a,u,h,f,l,d)}roundClean(){c.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class h extends u{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}e.sha256=(0,o.wrapConstructor)((()=>new u)),e.sha224=(0,o.wrapConstructor)((()=>new h))},89:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.randomBytes=e.wrapXOFConstructorWithOpts=e.wrapConstructorWithOpts=e.wrapConstructor=e.checkOpts=e.Hash=e.concatBytes=e.toBytes=e.utf8ToBytes=e.asyncLoop=e.nextTick=e.hexToBytes=e.bytesToHex=e.isLE=e.rotr=e.createView=e.u32=e.u8=void 0;const n=r(945),o=t=>t instanceof Uint8Array;if(e.u8=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength),e.u32=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),e.createView=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),e.rotr=(t,e)=>t<<32-e|t>>>e,e.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],!e.isLE)throw new Error("Non little-endian hardware is not supported");const i=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function s(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function a(t){if("string"==typeof t&&(t=s(t)),!o(t))throw new Error("expected Uint8Array, got "+typeof t);return t}e.bytesToHex=function(t){if(!o(t))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=i[t[r]];return e},e.hexToBytes=function(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(e/2);for(let e=0;e<r.length;e++){const n=2*e,o=t.slice(n,n+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");r[e]=i}return r},e.nextTick=async()=>{},e.asyncLoop=async function(t,r,n){let o=Date.now();for(let i=0;i<t;i++){n(i);const t=Date.now()-o;t>=0&&t<r||(await(0,e.nextTick)(),o+=t)}},e.utf8ToBytes=s,e.toBytes=a,e.concatBytes=function(...t){const e=new Uint8Array(t.reduce(((t,e)=>t+e.length),0));let r=0;return t.forEach((t=>{if(!o(t))throw new Error("Uint8Array expected");e.set(t,r),r+=t.length})),e},e.Hash=class{clone(){return this._cloneInto()}},e.checkOpts=function(t,e){if(void 0!==e&&("object"!=typeof e||(r=e,"[object Object]"!==Object.prototype.toString.call(r)||r.constructor!==Object)))throw new Error("Options should be object or undefined");var r;return Object.assign(t,e)},e.wrapConstructor=function(t){const e=e=>t().update(a(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e},e.wrapConstructorWithOpts=function(t){const e=(e,r)=>t(r).update(a(e)).digest(),r=t({});return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=e=>t(e),e},e.wrapXOFConstructorWithOpts=function(t){const e=(e,r)=>t(r).update(a(e)).digest(),r=t({});return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=e=>t(e),e},e.randomBytes=function(t=32){if(n.crypto&&"function"==typeof n.crypto.getRandomValues)return n.crypto.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}},656:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.utils=e.schnorr=e.verify=e.signSync=e.sign=e.getSharedSecret=e.recoverPublicKey=e.getPublicKey=e.Signature=e.Point=e.CURVE=void 0;const n=r(159),o=BigInt(0),i=BigInt(1),s=BigInt(2),a=BigInt(3),c=BigInt(8),u=Object.freeze({a:o,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:i,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});e.CURVE=u;const h=(t,e)=>(t+e/s)/e,f={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(t){const{n:e}=u,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-i*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=r,a=BigInt("0x100000000000000000000000000000000"),c=h(s*t,e),f=h(-n*t,e);let l=N(t-c*r-f*o,e),d=N(-c*n-f*s,e);const y=l>a,p=d>a;if(y&&(l=e-l),p&&(d=e-d),l>a||d>a)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:y,k1:l,k2neg:p,k2:d}}},l=32,d=32,y=l+1,p=2*l+1;function g(t){const{a:e,b:r}=u,n=N(t*t),o=N(n*t);return N(o+e*t+r)}const w=u.a===o;class b extends Error{constructor(t){super(t)}}function m(t){if(!(t instanceof v))throw new TypeError("JacobianPoint expected")}class v{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof A))throw new TypeError("JacobianPoint#fromAffine: expected Point");return t.equals(A.ZERO)?v.ZERO:new v(t.x,t.y,i)}static toAffineBatch(t){const e=function(t,e=u.P){const r=new Array(t.length),n=D(t.reduce(((t,n,i)=>n===o?t:(r[i]=t,N(t*n,e))),i),e);return t.reduceRight(((t,n,i)=>n===o?t:(r[i]=N(t*r[i],e),N(t*n,e))),n),r}(t.map((t=>t.z)));return t.map(((t,r)=>t.toAffine(e[r])))}static normalizeZ(t){return v.toAffineBatch(t).map(v.fromAffine)}equals(t){m(t);const{x:e,y:r,z:n}=this,{x:o,y:i,z:s}=t,a=N(n*n),c=N(s*s),u=N(e*c),h=N(o*a),f=N(N(r*s)*c),l=N(N(i*n)*a);return u===h&&f===l}negate(){return new v(this.x,N(-this.y),this.z)}double(){const{x:t,y:e,z:r}=this,n=N(t*t),o=N(e*e),i=N(o*o),u=t+o,h=N(s*(N(u*u)-n-i)),f=N(a*n),l=N(f*f),d=N(l-s*h),y=N(f*(h-d)-c*i),p=N(s*e*r);return new v(d,y,p)}add(t){m(t);const{x:e,y:r,z:n}=this,{x:i,y:a,z:c}=t;if(i===o||a===o)return this;if(e===o||r===o)return t;const u=N(n*n),h=N(c*c),f=N(e*h),l=N(i*u),d=N(N(r*c)*h),y=N(N(a*n)*u),p=N(l-f),g=N(y-d);if(p===o)return g===o?this.double():v.ZERO;const w=N(p*p),b=N(p*w),E=N(f*w),x=N(g*g-b-s*E),A=N(g*(E-x)-d*b),S=N(n*c*p);return new v(x,A,S)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=v.ZERO;if("bigint"==typeof t&&t===o)return e;let r=M(t);if(r===i)return this;if(!w){let t=e,n=this;for(;r>o;)r&i&&(t=t.add(n)),n=n.double(),r>>=i;return t}let{k1neg:n,k1:s,k2neg:a,k2:c}=f.splitScalar(r),u=e,h=e,l=this;for(;s>o||c>o;)s&i&&(u=u.add(l)),c&i&&(h=h.add(l)),l=l.double(),s>>=i,c>>=i;return n&&(u=u.negate()),a&&(h=h.negate()),h=new v(N(h.x*f.beta),h.y,h.z),u.add(h)}precomputeWindow(t){const e=w?128/t+1:256/t+1,r=[];let n=this,o=n;for(let i=0;i<e;i++){o=n,r.push(o);for(let e=1;e<2**(t-1);e++)o=o.add(n),r.push(o);n=o.double()}return r}wNAF(t,e){!e&&this.equals(v.BASE)&&(e=A.BASE);const r=e&&e._WINDOW_SIZE||1;if(256%r)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=e&&x.get(e);n||(n=this.precomputeWindow(r),e&&1!==r&&(n=v.normalizeZ(n),x.set(e,n)));let o=v.ZERO,s=v.BASE;const a=1+(w?128/r:256/r),c=2**(r-1),u=BigInt(2**r-1),h=2**r,f=BigInt(r);for(let e=0;e<a;e++){const r=e*c;let a=Number(t&u);t>>=f,a>c&&(a-=h,t+=i);const l=r,d=r+Math.abs(a)-1,y=e%2!=0,p=a<0;0===a?s=s.add(E(y,n[l])):o=o.add(E(p,n[d]))}return{p:o,f:s}}multiply(t,e){let r,n,o=M(t);if(w){const{k1neg:t,k1:i,k2neg:s,k2:a}=f.splitScalar(o);let{p:c,f:u}=this.wNAF(i,e),{p:h,f:l}=this.wNAF(a,e);c=E(t,c),h=E(s,h),h=new v(N(h.x*f.beta),h.y,h.z),r=c.add(h),n=u.add(l)}else{const{p:t,f:i}=this.wNAF(o,e);r=t,n=i}return v.normalizeZ([r,n])[0]}toAffine(t){const{x:e,y:r,z:n}=this,o=this.equals(v.ZERO);null==t&&(t=o?c:D(n));const s=t,a=N(s*s),u=N(a*s),h=N(e*a),f=N(r*u),l=N(n*s);if(o)return A.ZERO;if(l!==i)throw new Error("invZ was invalid");return new A(h,f)}}function E(t,e){const r=e.negate();return t?r:e}v.BASE=new v(u.Gx,u.Gy,i),v.ZERO=new v(o,i,o);const x=new WeakMap;class A{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,x.delete(this)}hasEvenY(){return this.y%s===o}static fromCompressedHex(t){const e=32===t.length,r=L(e?t:t.subarray(1));if(!F(r))throw new Error("Point is not on curve");let n=function(t){const{P:e}=u,r=BigInt(6),n=BigInt(11),o=BigInt(22),i=BigInt(23),c=BigInt(44),h=BigInt(88),f=t*t*t%e,l=f*f*t%e,d=$(l,a)*l%e,y=$(d,a)*l%e,p=$(y,s)*f%e,g=$(p,n)*p%e,w=$(g,o)*g%e,b=$(w,c)*w%e,m=$(b,h)*b%e,v=$(m,c)*w%e,E=$(v,a)*l%e,x=$(E,i)*g%e,A=$(x,r)*f%e,S=$(A,s);if(S*S%e!==t)throw new Error("Cannot find square root");return S}(g(r));const o=(n&i)===i;e?o&&(n=N(-n)):1==(1&t[0])!==o&&(n=N(-n));const c=new A(r,n);return c.assertValidity(),c}static fromUncompressedHex(t){const e=L(t.subarray(1,l+1)),r=L(t.subarray(l+1,2*l+1)),n=new A(e,r);return n.assertValidity(),n}static fromHex(t){const e=R(t),r=e.length,n=e[0];if(r===l)return this.fromCompressedHex(e);if(r===y&&(2===n||3===n))return this.fromCompressedHex(e);if(r===p&&4===n)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-${y} compressed bytes or ${p} uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return A.BASE.multiply(Z(t))}static fromSignature(t,e,r){const{r:n,s:o}=X(e);if(![0,1,2,3].includes(r))throw new Error("Cannot recover: invalid recovery bit");const i=q(R(t)),{n:s}=u,a=2===r||3===r?n+s:n,c=D(a,s),h=N(-i*c,s),f=N(o*c,s),l=1&r?"03":"02",d=A.fromHex(l+U(a)),y=A.BASE.multiplyAndAddUnsafe(d,h,f);if(!y)throw new Error("Cannot recover signature: point at infinify");return y.assertValidity(),y}toRawBytes(t=!1){return j(this.toHex(t))}toHex(t=!1){const e=U(this.x);return t?`${this.hasEvenY()?"02":"03"}${e}`:`04${e}${U(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:r}=this;if(!F(e)||!F(r))throw new Error(t);const n=N(r*r);if(N(n-g(e))!==o)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new A(this.x,N(-this.y))}double(){return v.fromAffine(this).double().toAffine()}add(t){return v.fromAffine(this).add(v.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return v.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){const n=v.fromAffine(this),s=e===o||e===i||this!==A.BASE?n.multiplyUnsafe(e):n.multiply(e),a=v.fromAffine(t).multiplyUnsafe(r),c=s.add(a);return c.equals(v.ZERO)?void 0:c.toAffine()}}function S(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function B(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${H(t)}`);const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:L(r),left:t.subarray(e+2)}}e.Point=A,A.BASE=new A(u.Gx,u.Gy),A.ZERO=new A(o,o);class P{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,r="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${r}: Expected string or Uint8Array`);const n=e?H(t):t;if(128!==n.length)throw new Error(`${r}: Expected 64-byte hex`);return new P(T(n.slice(0,64)),T(n.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r,s:n}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${H(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:r}=B(t.subarray(2)),{data:n,left:o}=B(r);if(o.length)throw new Error(`Invalid signature: left bytes after parsing: ${H(o)}`);return{r:e,s:n}}(e?t:j(t));return new P(r,n)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!V(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!V(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=u.n>>i;return this.s>t}normalizeS(){return this.hasHighS()?new P(this.r,N(-this.s,u.n)):this}toDERRawBytes(){return j(this.toDERHex())}toDERHex(){const t=S(I(this.s)),e=S(I(this.r)),r=t.length/2,n=e.length/2,o=I(r),i=I(n);return`30${I(n+r+4)}02${i}${e}02${o}${t}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return j(this.toCompactHex())}toCompactHex(){return U(this.r)+U(this.s)}}function C(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const o=t[e];r.set(o,n),n+=o.length}return r}e.Signature=P;const _=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function H(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let r=0;r<t.length;r++)e+=_[t[r]];return e}const O=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function U(t){if("bigint"!=typeof t)throw new Error("Expected bigint");if(!(o<=t&&t<O))throw new Error("Expected number 0 <= n < 2^256");return t.toString(16).padStart(64,"0")}function k(t){const e=j(U(t));if(32!==e.length)throw new Error("Error: expected 32 bytes");return e}function I(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function T(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function j(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let r=0;r<e.length;r++){const n=2*r,o=t.slice(n,n+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");e[r]=i}return e}function L(t){return T(H(t))}function R(t){return t instanceof Uint8Array?Uint8Array.from(t):j(t)}function M(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&V(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function N(t,e=u.P){const r=t%e;return r>=o?r:e+r}function $(t,e){const{P:r}=u;let n=t;for(;e-- >o;)n*=n,n%=r;return n}function D(t,e=u.P){if(t===o||e<=o)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=N(t,e),n=e,s=o,a=i,c=i,h=o;for(;r!==o;){const t=n/r,e=n%r,o=s-c*t,i=a-h*t;n=r,r=e,s=c,a=h,c=o,h=i}if(n!==i)throw new Error("invert: does not exist");return N(s,e)}function q(t,e=!1){const r=function(t){const e=8*t.length-8*d,r=L(t);return e>0?r>>BigInt(e):r}(t);if(e)return r;const{n}=u;return r>=n?r-n:r}let K,W;class z{constructor(t,e){if(this.hashLen=t,this.qByteLen=e,"number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(t).fill(1),this.k=new Uint8Array(t).fill(0),this.counter=0}hmac(...t){return e.utils.hmacSha256(this.k,...t)}hmacSync(...t){return W(this.k,...t)}checkSync(){if("function"!=typeof W)throw new b("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){this.incr();let t=0;const e=[];for(;t<this.qByteLen;){this.v=await this.hmac(this.v);const r=this.v.slice();e.push(r),t+=this.v.length}return C(...e)}generateSync(){this.checkSync(),this.incr();let t=0;const e=[];for(;t<this.qByteLen;){this.v=this.hmacSync(this.v);const r=this.v.slice();e.push(r),t+=this.v.length}return C(...e)}}function V(t){return o<t&&t<u.n}function F(t){return o<t&&t<u.P}function J(t,e,r,n=!0){const{n:s}=u,a=q(t,!0);if(!V(a))return;const c=D(a,s),h=A.BASE.multiply(a),f=N(h.x,s);if(f===o)return;const l=N(c*N(e+r*f,s),s);if(l===o)return;let d=new P(f,l),y=(h.x===d.r?0:2)|Number(h.y&i);return n&&d.hasHighS()&&(d=d.normalizeS(),y^=1),{sig:d,recovery:y}}function Z(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(t.length!==2*d)throw new Error("Expected 32 bytes of private key");e=T(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(t.length!==d)throw new Error("Expected 32 bytes of private key");e=L(t)}if(!V(e))throw new Error("Expected private key: 0 < key < n");return e}function G(t){return t instanceof A?(t.assertValidity(),t):A.fromHex(t)}function X(t){if(t instanceof P)return t.assertValidity(),t;try{return P.fromDER(t)}catch(e){return P.fromCompact(t)}}function Y(t){const e=t instanceof Uint8Array,r="string"==typeof t,n=(e||r)&&t.length;return e?n===y||n===p:r?n===2*y||n===2*p:t instanceof A}function Q(t){return L(t.length>l?t.slice(0,l):t)}function tt(t){const e=Q(t),r=N(e,u.n);return et(r<o?e:r)}function et(t){return k(t)}function rt(t,r,n){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const o=R(t),i=Z(r),s=[et(i),tt(o)];if(null!=n){!0===n&&(n=e.utils.randomBytes(l));const t=R(n);if(t.length!==l)throw new Error(`sign: Expected ${l} bytes of extra data`);s.push(t)}return{seed:C(...s),m:Q(o),d:i}}function nt(t,e){const{sig:r,recovery:n}=t,{der:o,recovered:i}=Object.assign({canonical:!0,der:!0},e),s=o?r.toDERRawBytes():r.toCompactRawBytes();return i?[s,n]:s}e.getPublicKey=function(t,e=!1){return A.fromPrivateKey(t).toRawBytes(e)},e.recoverPublicKey=function(t,e,r,n=!1){return A.fromSignature(t,e,r).toRawBytes(n)},e.getSharedSecret=function(t,e,r=!1){if(Y(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!Y(e))throw new TypeError("getSharedSecret: second arg must be public key");const n=G(e);return n.assertValidity(),n.multiply(Z(t)).toRawBytes(r)},e.sign=async function(t,e,r={}){const{seed:n,m:o,d:i}=rt(t,e,r.extraEntropy),s=new z(32,d);let a;for(await s.reseed(n);!(a=J(await s.generate(),o,i,r.canonical));)await s.reseed();return nt(a,r)},e.signSync=function(t,e,r={}){const{seed:n,m:o,d:i}=rt(t,e,r.extraEntropy),s=new z(32,d);let a;for(s.reseedSync(n);!(a=J(s.generateSync(),o,i,r.canonical));)s.reseedSync();return nt(a,r)};const ot={strict:!0};function it(t){return N(L(t),u.n)}e.verify=function(t,e,r,n=ot){let o;try{o=X(t),e=R(e)}catch(t){return!1}const{r:i,s}=o;if(n.strict&&o.hasHighS())return!1;const a=q(e);let c;try{c=G(r)}catch(t){return!1}const{n:h}=u,f=D(s,h),l=N(a*f,h),d=N(i*f,h),y=A.BASE.multiplyAndAddUnsafe(c,l,d);return!!y&&N(y.x,h)===i};class st{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=R(t);if(64!==e.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);const r=L(e.subarray(0,32)),n=L(e.subarray(32,64));return new st(r,n)}assertValidity(){const{r:t,s:e}=this;if(!F(t)||!V(e))throw new Error("Invalid signature")}toHex(){return U(this.r)+U(this.s)}toRawBytes(){return j(this.toHex())}}class at{constructor(t,r,n=e.utils.randomBytes()){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);this.m=R(t);const{x:o,scalar:i}=this.getScalar(Z(r));if(this.px=o,this.d=i,this.rand=R(n),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(t){const e=A.fromPrivateKey(t),r=e.hasEvenY()?t:u.n-t;return{point:e,scalar:r,x:e.toRawX()}}initNonce(t,e){return k(t^L(e))}finalizeNonce(t){const e=N(L(t),u.n);if(e===o)throw new Error("sign: Creation of signature failed. k is zero");const{point:r,x:n,scalar:i}=this.getScalar(e);return{R:r,rx:n,k:i}}finalizeSig(t,e,r,n){return new st(t.x,N(e+r*n,u.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m:t,d:r,px:n,rand:o}=this,i=e.utils.taggedHash,s=this.initNonce(r,await i(dt.aux,o)),{R:a,rx:c,k:u}=this.finalizeNonce(await i(dt.nonce,s,n,t)),h=it(await i(dt.challenge,c,n,t)),f=this.finalizeSig(a,u,h,r);return await ht(f,t,n)||this.error(),f}calcSync(){const{m:t,d:r,px:n,rand:o}=this,i=e.utils.taggedHashSync,s=this.initNonce(r,i(dt.aux,o)),{R:a,rx:c,k:u}=this.finalizeNonce(i(dt.nonce,s,n,t)),h=it(i(dt.challenge,c,n,t)),f=this.finalizeSig(a,u,h,r);return ft(f,t,n)||this.error(),f}}function ct(t,e,r){const n=t instanceof st,o=n?t:st.fromHex(t);return n&&o.assertValidity(),{...o,m:R(e),P:G(r)}}function ut(t,e,r,n){const o=A.BASE.multiplyAndAddUnsafe(e,Z(r),N(-n,u.n));return!(!o||!o.hasEvenY()||o.x!==t)}async function ht(t,r,n){try{const{r:o,s:i,m:s,P:a}=ct(t,r,n),c=it(await e.utils.taggedHash(dt.challenge,k(o),a.toRawX(),s));return ut(o,a,i,c)}catch(t){return!1}}function ft(t,r,n){try{const{r:o,s:i,m:s,P:a}=ct(t,r,n),c=it(e.utils.taggedHashSync(dt.challenge,k(o),a.toRawX(),s));return ut(o,a,i,c)}catch(t){if(t instanceof b)throw t;return!1}}e.schnorr={Signature:st,getPublicKey:function(t){return A.fromPrivateKey(t).toRawX()},sign:async function(t,e,r){return new at(t,e,r).calc()},verify:ht,signSync:function(t,e,r){return new at(t,e,r).calcSync()},verifySync:ft},A.BASE._setWindowSize(8);const lt={node:n,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},dt={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},yt={};e.utils={bytesToHex:H,hexToBytes:j,concatBytes:C,mod:N,invert:D,isValidPrivateKey(t){try{return Z(t),!0}catch(t){return!1}},_bigintTo32Bytes:k,_normalizePrivateKey:Z,hashToPrivateKey:t=>{t=R(t);const e=d+8;if(t.length<e||t.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");return k(N(L(t),u.n-i)+i)},randomBytes:(t=32)=>{if(lt.web)return lt.web.getRandomValues(new Uint8Array(t));if(lt.node){const{randomBytes:e}=lt.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>e.utils.hashToPrivateKey(e.utils.randomBytes(d+8)),precompute(t=8,e=A.BASE){const r=e===A.BASE?e:new A(e.x,e.y);return r._setWindowSize(t),r.multiply(a),r},sha256:async(...t)=>{if(lt.web){const e=await lt.web.subtle.digest("SHA-256",C(...t));return new Uint8Array(e)}if(lt.node){const{createHash:e}=lt.node,r=e("sha256");return t.forEach((t=>r.update(t))),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(lt.web){const r=await lt.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=C(...e),o=await lt.web.subtle.sign("HMAC",r,n);return new Uint8Array(o)}if(lt.node){const{createHmac:r}=lt.node,n=r("sha256",t);return e.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...r)=>{let n=yt[t];if(void 0===n){const r=await e.utils.sha256(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=C(r,r),yt[t]=n}return e.utils.sha256(n,...r)},taggedHashSync:(t,...e)=>{if("function"!=typeof K)throw new b("sha256Sync is undefined, you need to set it");let r=yt[t];if(void 0===r){const e=K(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=C(e,e),yt[t]=r}return K(r,...e)},_JacobianPoint:v},Object.defineProperties(e.utils,{sha256Sync:{configurable:!1,get:()=>K,set(t){K||(K=t)}},hmacSha256Sync:{configurable:!1,get:()=>W,set(t){W||(W=t)}}})},742:(t,e)=>{"use strict";e.byteLength=function(t){var e=a(t),r=e[0],n=e[1];return 3*(r+n)/4-n},e.toByteArray=function(t){var e,r,i=a(t),s=i[0],c=i[1],u=new o(function(t,e,r){return 3*(e+r)/4-r}(0,s,c)),h=0,f=c>0?s-4:s;for(r=0;r<f;r+=4)e=n[t.charCodeAt(r)]<<18|n[t.charCodeAt(r+1)]<<12|n[t.charCodeAt(r+2)]<<6|n[t.charCodeAt(r+3)],u[h++]=e>>16&255,u[h++]=e>>8&255,u[h++]=255&e;return 2===c&&(e=n[t.charCodeAt(r)]<<2|n[t.charCodeAt(r+1)]>>4,u[h++]=255&e),1===c&&(e=n[t.charCodeAt(r)]<<10|n[t.charCodeAt(r+1)]<<4|n[t.charCodeAt(r+2)]>>2,u[h++]=e>>8&255,u[h++]=255&e),u},e.fromByteArray=function(t){for(var e,n=t.length,o=n%3,i=[],s=16383,a=0,u=n-o;a<u;a+=s)i.push(c(t,a,a+s>u?u:a+s));return 1===o?(e=t[n-1],i.push(r[e>>2]+r[e<<4&63]+"==")):2===o&&(e=(t[n-2]<<8)+t[n-1],i.push(r[e>>10]+r[e>>4&63]+r[e<<2&63]+"=")),i.join("")};for(var r=[],n=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0;s<64;++s)r[s]=i[s],n[i.charCodeAt(s)]=s;function a(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");return-1===r&&(r=e),[r,r===e?0:4-r%4]}function c(t,e,n){for(var o,i,s=[],a=e;a<n;a+=3)o=(t[a]<<16&16711680)+(t[a+1]<<8&65280)+(255&t[a+2]),s.push(r[(i=o)>>18&63]+r[i>>12&63]+r[i>>6&63]+r[63&i]);return s.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},764:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.decode=e.encode=e.unescape=e.escape=e.pad=void 0;const n=r(742);function o(t){return`${t}${"=".repeat(4-(t.length%4||4))}`}function i(t){return t.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function s(t){return o(t).replace(/-/g,"+").replace(/_/g,"/")}e.pad=o,e.escape=i,e.unescape=s,e.encode=function(t){return i((0,n.fromByteArray)((new TextEncoder).encode(t)))},e.decode=function(t){return(new TextDecoder).decode((0,n.toByteArray)(o(s(t))))}},803:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.cryptoClients=e.SECP256K1Client=void 0;const n=r(118);Object.defineProperty(e,"SECP256K1Client",{enumerable:!0,get:function(){return n.SECP256K1Client}});const o={ES256K:n.SECP256K1Client};e.cryptoClients=o},118:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.SECP256K1Client=void 0;const n=r(569),o=r(61),i=r(656),s=r(563),a=r(581),c=r(89);i.utils.hmacSha256Sync=(t,...e)=>{const r=n.hmac.create(o.sha256,t);return e.forEach((t=>r.update(t))),r.digest()};class u{static derivePublicKey(t,e=!0){return 66===t.length&&(t=t.slice(0,64)),t.length<64&&(t=t.padStart(64,"0")),(0,c.bytesToHex)(i.getPublicKey(t,e))}static signHash(t,e,r="jose"){if(!t||!e)throw new a.MissingParametersError("a signing input hash and private key are all required");const n=i.signSync(t,e.slice(0,64),{der:!0,canonical:!1});if("der"===r)return(0,c.bytesToHex)(n);if("jose"===r)return(0,s.derToJose)(n,"ES256");throw Error("Invalid signature format")}static loadSignature(t){return(0,s.joseToDer)(t,"ES256")}static verifyHash(t,e,r){if(!t||!e||!r)throw new a.MissingParametersError("a signing input hash, der signature, and public key are all required");return i.verify(e,t,r,{strict:!1})}}e.SECP256K1Client=u,u.algorithmName="ES256K"},674:function(t,e,r){"use strict";var n=this&&this.__awaiter||function(t,e,r,n){return new(r||(r=Promise))((function(o,i){function s(t){try{c(n.next(t))}catch(t){i(t)}}function a(t){try{c(n.throw(t))}catch(t){i(t)}}function c(t){var e;t.done?o(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(s,a)}c((n=n.apply(t,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0}),e.hashSha256Async=e.hashSha256=void 0;const o=r(61);function i(t){return(0,o.sha256)(t)}e.hashSha256=i,e.hashSha256Async=function(t){return n(this,void 0,void 0,(function*(){try{if("undefined"!=typeof crypto&&void 0!==crypto.subtle){const e="string"==typeof t?(new TextEncoder).encode(t):t,r=yield crypto.subtle.digest("SHA-256",e);return new Uint8Array(r)}{const e=r(971);if(!e.createHash)throw new Error("`crypto` module does not contain `createHash`");return Promise.resolve(e.createHash("sha256").update(t).digest())}}catch(e){return console.log(e),console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'),Promise.resolve(i(t))}}))}},891:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.decodeToken=void 0;const n=r(764);e.decodeToken=function(t){if("string"==typeof t){const e=t.split(".");return{header:JSON.parse(n.decode(e[0])),payload:JSON.parse(n.decode(e[1])),signature:e[2]}}if("object"==typeof t){if("string"!=typeof t.payload)throw new Error("Expected token payload to be a base64 or json string");let e=t.payload;"{"!==t.payload[0]&&(e=n.decode(e));const r=[];return t.header.map((t=>{const e=JSON.parse(n.decode(t));r.push(e)})),{header:r,payload:JSON.parse(e),signature:t.signature}}}},563:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.joseToDer=e.derToJose=void 0;const n=r(742),o=r(764);function i(t){return(t/8|0)+(t%8==0?0:1)}const s={ES256:i(256),ES384:i(384),ES512:i(521)};function a(t){const e=s[t];if(e)return e;throw new Error(`Unknown algorithm "${t}"`)}const c=128;function u(t){if(t instanceof Uint8Array)return t;if("string"==typeof t)return(0,n.toByteArray)((0,o.pad)(t));throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array")}function h(t,e,r){let n=0;for(;e+n<r&&0===t[e+n];)++n;return t[e+n]>=c&&--n,n}e.derToJose=function(t,e){const r=u(t),i=a(e),s=i+1,c=r.length;let h=0;if(48!==r[h++])throw new Error('Could not find expected "seq"');let f=r[h++];if(129===f&&(f=r[h++]),c-h<f)throw new Error(`"seq" specified length of "${f}", only "${c-h}" remaining`);if(2!==r[h++])throw new Error('Could not find expected "int" for "r"');const l=r[h++];if(c-h-2<l)throw new Error(`"r" specified length of "${l}", only "${c-h-2}" available`);if(s<l)throw new Error(`"r" specified length of "${l}", max of "${s}" is acceptable`);const d=h;if(h+=l,2!==r[h++])throw new Error('Could not find expected "int" for "s"');const y=r[h++];if(c-h!==y)throw new Error(`"s" specified length of "${y}", expected "${c-h}"`);if(s<y)throw new Error(`"s" specified length of "${y}", max of "${s}" is acceptable`);const p=h;if(h+=y,h!==c)throw new Error(`Expected to consume entire array, but "${c-h}" bytes remain`);const g=i-l,w=i-y,b=new Uint8Array(g+l+w+y);for(h=0;h<g;++h)b[h]=0;b.set(r.subarray(d+Math.max(-g,0),d+l),h),h=i;for(const t=h;h<t+w;++h)b[h]=0;return b.set(r.subarray(p+Math.max(-w,0),p+y),h),(0,o.escape)((0,n.fromByteArray)(b))},e.joseToDer=function(t,e){t=u(t);const r=a(e),n=t.length;if(n!==2*r)throw new TypeError(`"${e}" signatures must be "${2*r}" bytes, saw "${n}"`);const o=h(t,0,r),i=h(t,r,t.length),s=r-o,f=r-i,l=2+s+1+1+f,d=l<c,y=new Uint8Array((d?2:3)+l);let p=0;return y[p++]=48,d?y[p++]=l:(y[p++]=129,y[p++]=255&l),y[p++]=2,y[p++]=s,o<0?(y[p++]=0,y.set(t.subarray(0,r),p),p+=r):(y.set(t.subarray(o,r),p),p+=r-o),y[p++]=2,y[p++]=f,i<0?(y[p++]=0,y.set(t.subarray(r),p)):y.set(t.subarray(r+i),p),y}},581:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.InvalidTokenError=e.MissingParametersError=void 0;class r extends Error{constructor(t){super(),this.name="MissingParametersError",this.message=t||""}}e.MissingParametersError=r;class n extends Error{constructor(t){super(),this.name="InvalidTokenError",this.message=t||""}}e.InvalidTokenError=n},80:function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(e,r);o&&!("get"in o?!e.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,o)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),o=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),o(r(298),e),o(r(523),e),o(r(891),e),o(r(581),e),o(r(803),e)},298:function(t,e,r){"use strict";var n=this&&this.__awaiter||function(t,e,r,n){return new(r||(r=Promise))((function(o,i){function s(t){try{c(n.next(t))}catch(t){i(t)}}function a(t){try{c(n.throw(t))}catch(t){i(t)}}function c(t){var e;t.done?o(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(s,a)}c((n=n.apply(t,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0}),e.TokenSigner=e.createUnsecuredToken=void 0;const o=r(764),i=r(803),s=r(581),a=r(674);function c(t,e){const r=[],n=o.encode(JSON.stringify(e));r.push(n);const i=o.encode(JSON.stringify(t));return r.push(i),r.join(".")}e.createUnsecuredToken=function(t){return c(t,{typ:"JWT",alg:"none"})+"."},e.TokenSigner=class{constructor(t,e){if(!t||!e)throw new s.MissingParametersError("a signing algorithm and private key are required");if("string"!=typeof t)throw new Error("signing algorithm parameter must be a string");if(t=t.toUpperCase(),!i.cryptoClients.hasOwnProperty(t))throw new Error("invalid signing algorithm");this.tokenType="JWT",this.cryptoClient=i.cryptoClients[t],this.rawPrivateKey=e}header(t={}){const e={typ:this.tokenType,alg:this.cryptoClient.algorithmName};return Object.assign({},e,t)}sign(t,e=!1,r={}){const n=this.header(r),o=c(t,n),i=(0,a.hashSha256)(o);return this.createWithSignedHash(t,e,n,o,i)}signAsync(t,e=!1,r={}){return n(this,void 0,void 0,(function*(){const n=this.header(r),o=c(t,n),i=yield(0,a.hashSha256Async)(o);return this.createWithSignedHash(t,e,n,o,i)}))}createWithSignedHash(t,e,r,n,i){const s=this.cryptoClient.signHash(i,this.rawPrivateKey);return e?{header:[o.encode(JSON.stringify(r))],payload:JSON.stringify(t),signature:[s]}:[n,s].join(".")}}},523:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.TokenVerifier=void 0;const n=r(764),o=r(803),i=r(581),s=r(674);e.TokenVerifier=class{constructor(t,e){if(!t||!e)throw new i.MissingParametersError("a signing algorithm and public key are required");if("string"!=typeof t)throw"signing algorithm parameter must be a string";if(t=t.toUpperCase(),!o.cryptoClients.hasOwnProperty(t))throw"invalid signing algorithm";this.tokenType="JWT",this.cryptoClient=o.cryptoClients[t],this.rawPublicKey=e}verify(t){return"string"==typeof t?this.verifyCompact(t,!1):"object"==typeof t&&this.verifyExpanded(t,!1)}verifyAsync(t){return"string"==typeof t?this.verifyCompact(t,!0):"object"==typeof t?this.verifyExpanded(t,!0):Promise.resolve(!1)}verifyCompact(t,e){const r=t.split("."),n=r[0]+"."+r[1],o=t=>{const e=this.cryptoClient.loadSignature(r[2]);return this.cryptoClient.verifyHash(t,e,this.rawPublicKey)};if(e)return(0,s.hashSha256Async)(n).then((t=>o(t)));{const t=(0,s.hashSha256)(n);return o(t)}}verifyExpanded(t,e){const r=[t.header.join("."),n.encode(t.payload)].join(".");let o=!0;const i=e=>(t.signature.map((t=>{const r=this.cryptoClient.loadSignature(t);this.cryptoClient.verifyHash(e,r,this.rawPublicKey)||(o=!1)})),o);if(e)return(0,s.hashSha256Async)(r).then((t=>i(t)));{const t=(0,s.hashSha256)(r);return i(t)}}}},530:function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(e,r);o&&!("get"in o?!e.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,o)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),o=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),o(r(859),e),o(r(497),e),o(r(337),e),o(r(715),e),o(r(248),e)},859:function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(e,r);o&&!("get"in o?!e.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,o)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),o=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),e.getAddress=void 0;const i=r(80);e.getAddress=async t=>{const{message:e,network:r,purposes:n}=t.payload,o=window.BitcoinProvider;if(!o)throw new Error("No Bitcoin Wallet installed");if(!n)throw new Error("Address purposes are required");try{const e=(0,i.createUnsecuredToken)(t.payload),r=await o.connect(e);t.onFinish?.(r)}catch(e){console.error("[Connect] Error during address request",e),t.onCancel?.()}},o(r(252),e)},252:(t,e)=>{"use strict";var r;Object.defineProperty(e,"__esModule",{value:!0}),e.AddressPurposes=void 0,(r=e.AddressPurposes||(e.AddressPurposes={})).PAYMENT="payment",r.ORDINALS="ordinals"},337:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.callWalletPopup=e.CallMethod=void 0;const n=r(80);var o;(o=e.CallMethod||(e.CallMethod={})).SIGN_TRANSACTION="signTransaction",o.GET_ADDRESS="getAddress",e.callWalletPopup=async t=>{const e=window.BitcoinProvider,{method:r}=t.payload;if(!e)throw new Error("No Bitcoin Wallet installed");if(!r)throw new Error("A wallet method is required");const o=(0,n.createUnsecuredToken)(t.payload);try{const r=await e.call(o);t.onFinish?.(r)}catch(e){console.error("[Connect] Error during call request",e),t.onCancel?.()}}},497:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0})},248:function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(e,r);o&&!("get"in o?!e.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,o)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),o=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),e.signMessage=void 0;const i=r(80);e.signMessage=async t=>{const e=window.BitcoinProvider;if(!e)throw new Error("No Bitcoin Wallet installed");try{const r=(0,i.createUnsecuredToken)(t.payload),n=await e.signMessage(r);t.onFinish?.(n)}catch(e){console.error("[Connect] Error during Signing request",e),t.onCancel?.()}},o(r(292),e)},292:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0})},715:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.signTransaction=void 0;const n=r(80);e.signTransaction=async t=>{const{psbtBase64:e,inputsToSign:r}=t.payload,o=window.BitcoinProvider;if(!o)throw new Error("No Bitcoin Wallet installed");if(!e)throw new Error("a value for psbtBase64 representing the tx hash is required");if(!r)throw new Error("an array specifying the inputs to be signed by the wallet is required");try{const e=(0,n.createUnsecuredToken)(t.payload),r=await o.signTransaction(e);t.onFinish?.(r)}catch(e){console.error("[Connect] Error during signPsbt request",e),t.onCancel?.()}}},159:()=>{},971:()=>{}},e={};function r(n){var o=e[n];if(void 0!==o)return o.exports;var i=e[n]={exports:{}};return t[n].call(i.exports,i,i.exports,r),i.exports}(()=>{const{getAddress:t}=r(530);document.getElementById("connect-wallet").addEventListener("click",(async()=>{const e=document.getElementById("wallet-selector").value;"unisat"===e?await async function(){if(window.unisat)try{const t=await window.unisat.requestAccounts();if(t[0]){const e=await fetch(`https://b33pb00p-4d7029c0887f.herokuapp.com/wallet/${t[0]}`),r=await e.json();if(r.imageURLs&&r.imageURLs.length>0){const t=document.getElementById("asset-link");t.innerHTML="";const e=["Full color","Monochromatic"];for(let n=0;n<r.imageURLs.length;n++){const o=document.createElement("a");o.href=r.imageURLs[n],o.textContent=e[n]?e[n]:`Click here to download asset ${n+1}`,o.target="_blank",t.appendChild(o)}}else alert("Unable to verify wallet.")}}catch(t){console.log("Connect failed",t)}else console.log("UniSat Wallet is not installed!")}():"sats-connect"===e?await async function(){const e={payload:{purposes:["payment"],message:"Address for receiving payments",network:{type:"Mainnet"}},onFinish:async t=>{const e=t.addresses.filter((t=>"payment"===t.purpose));if(e.length>0){const t=e[0].address,r=await fetch(`https://b33pb00p-4d7029c0887f.herokuapp.com/wallet/${t}`),n=await r.json();if(n.imageURLs&&n.imageURLs.length>0){const t=document.getElementById("asset-link");t.innerHTML="";const e=["Full color","Monochromatic"];for(let r=0;r<n.imageURLs.length;r++){const o=document.createElement("a");o.href=n.imageURLs[r],o.textContent=e[r]?e[r]:`Click here to download asset ${r+1}`,o.target="_blank",t.appendChild(o)}}else alert("Unable to verify wallet.")}else console.log("No payment address found")},onCancel:()=>console.log("Request canceled")};await t(e)}():console.log("Unknown wallet type!")}))})()})();