/*! For license information please see walletConnections.bundle.js.LICENSE.txt */
(()=>{var t={320:(t,e)=>{"use strict";function r(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function n(t){if("boolean"!=typeof t)throw new Error(`Expected boolean, not ${t}`)}function o(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function i(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");r(t.outputLen),r(t.blockLen)}function s(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function a(t,e){o(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}Object.defineProperty(e,"__esModule",{value:!0}),e.output=e.exists=e.hash=e.bytes=e.bool=e.number=void 0,e.number=r,e.bool=n,e.bytes=o,e.hash=i,e.exists=s,e.output=a;const c={number:r,bool:n,bytes:o,hash:i,exists:s,output:a};e.default=c},505:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.SHA2=void 0;const n=r(320),o=r(89);class i extends o.Hash{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=(0,o.createView)(this.buffer)}update(t){n.default.exists(this);const{view:e,buffer:r,blockLen:i}=this,s=(t=(0,o.toBytes)(t)).length;for(let n=0;n<s;){const a=Math.min(i-this.pos,s-n);if(a!==i)r.set(t.subarray(n,n+a),this.pos),this.pos+=a,n+=a,this.pos===i&&(this.process(e,0),this.pos=0);else{const e=(0,o.createView)(t);for(;i<=s-n;n+=i)this.process(e,n)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){n.default.exists(this),n.default.output(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:i,isLE:s}=this;let{pos:a}=this;e[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>i-a&&(this.process(r,0),a=0);for(let t=a;t<i;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),a=Number(r&i),c=n?4:0,u=n?0:4;t.setUint32(e+c,s,n),t.setUint32(e+u,a,n)}(r,i-8,BigInt(8*this.length),s),this.process(r,0);const c=(0,o.createView)(t),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=u/4,f=this.get();if(h>f.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<h;t++)c.setUint32(4*t,f[t],s)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:o,destroyed:i,pos:s}=this;return t.length=n,t.pos=s,t.finished=o,t.destroyed=i,n%e&&t.buffer.set(r),t}}e.SHA2=i},945:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.crypto=void 0,e.crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},569:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.hmac=e.HMAC=void 0;const n=r(320),o=r(89);class i extends o.Hash{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,n.default.hash(t);const r=(0,o.toBytes)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(r.length>i?t.create().update(r).digest():r);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),s.fill(0)}update(t){return n.default.exists(this),this.iHash.update(t),this}digestInto(t){n.default.exists(this),n.default.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=n,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}e.HMAC=i,e.hmac=(t,e,r)=>new i(t,e).update(r).digest(),e.hmac.create=(t,e)=>new i(t,e)},61:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sha224=e.sha256=void 0;const n=r(505),o=r(89),i=(t,e,r)=>t&e^t&r^e&r,s=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),a=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),c=new Uint32Array(64);class u extends n.SHA2{constructor(){super(64,32,8,!1),this.A=0|a[0],this.B=0|a[1],this.C=0|a[2],this.D=0|a[3],this.E=0|a[4],this.F=0|a[5],this.G=0|a[6],this.H=0|a[7]}get(){const{A:t,B:e,C:r,D:n,E:o,F:i,G:s,H:a}=this;return[t,e,r,n,o,i,s,a]}set(t,e,r,n,o,i,s,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)c[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=c[t-15],r=c[t-2],n=(0,o.rotr)(e,7)^(0,o.rotr)(e,18)^e>>>3,i=(0,o.rotr)(r,17)^(0,o.rotr)(r,19)^r>>>10;c[t]=i+c[t-7]+n+c[t-16]|0}let{A:r,B:n,C:a,D:u,E:h,F:f,G:l,H:d}=this;for(let t=0;t<64;t++){const e=d+((0,o.rotr)(h,6)^(0,o.rotr)(h,11)^(0,o.rotr)(h,25))+((y=h)&f^~y&l)+s[t]+c[t]|0,p=((0,o.rotr)(r,2)^(0,o.rotr)(r,13)^(0,o.rotr)(r,22))+i(r,n,a)|0;d=l,l=f,f=h,h=u+e|0,u=a,a=n,n=r,r=e+p|0}var y;r=r+this.A|0,n=n+this.B|0,a=a+this.C|0,u=u+this.D|0,h=h+this.E|0,f=f+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(r,n,a,u,h,f,l,d)}roundClean(){c.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class h extends u{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}e.sha256=(0,o.wrapConstructor)((()=>new u)),e.sha224=(0,o.wrapConstructor)((()=>new h))},89:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.randomBytes=e.wrapXOFConstructorWithOpts=e.wrapConstructorWithOpts=e.wrapConstructor=e.checkOpts=e.Hash=e.concatBytes=e.toBytes=e.utf8ToBytes=e.asyncLoop=e.nextTick=e.hexToBytes=e.bytesToHex=e.isLE=e.rotr=e.createView=e.u32=e.u8=void 0;const n=r(945),o=t=>t instanceof Uint8Array;if(e.u8=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength),e.u32=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),e.createView=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),e.rotr=(t,e)=>t<<32-e|t>>>e,e.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],!e.isLE)throw new Error("Non little-endian hardware is not supported");const i=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function s(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function a(t){if("string"==typeof t&&(t=s(t)),!o(t))throw new Error("expected Uint8Array, got "+typeof t);return t}e.bytesToHex=function(t){if(!o(t))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=i[t[r]];return e},e.hexToBytes=function(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(e/2);for(let e=0;e<r.length;e++){const n=2*e,o=t.slice(n,n+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");r[e]=i}return r},e.nextTick=async()=>{},e.asyncLoop=async function(t,r,n){let o=Date.now();for(let i=0;i<t;i++){n(i);const t=Date.now()-o;t>=0&&t<r||(await(0,e.nextTick)(),o+=t)}},e.utf8ToBytes=s,e.toBytes=a,e.concatBytes=function(...t){const e=new Uint8Array(t.reduce(((t,e)=>t+e.length),0));let r=0;return t.forEach((t=>{if(!o(t))throw new Error("Uint8Array expected");e.set(t,r),r+=t.length})),e},e.Hash=class{clone(){return this._cloneInto()}},e.checkOpts=function(t,e){if(void 0!==e&&("object"!=typeof e||(r=e,"[object Object]"!==Object.prototype.toString.call(r)||r.constructor!==Object)))throw new Error("Options should be object or undefined");var r;return Object.assign(t,e)},e.wrapConstructor=function(t){const e=e=>t().update(a(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e},e.wrapConstructorWithOpts=function(t){const e=(e,r)=>t(r).update(a(e)).digest(),r=t({});return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=e=>t(e),e},e.wrapXOFConstructorWithOpts=function(t){const e=(e,r)=>t(r).update(a(e)).digest(),r=t({});return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=e=>t(e),e},e.randomBytes=function(t=32){if(n.crypto&&"function"==typeof n.crypto.getRandomValues)return n.crypto.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}},656:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.utils=e.schnorr=e.verify=e.signSync=e.sign=e.getSharedSecret=e.recoverPublicKey=e.getPublicKey=e.Signature=e.Point=e.CURVE=void 0;const n=r(159),o=BigInt(0),i=BigInt(1),s=BigInt(2),a=BigInt(3),c=BigInt(8),u=Object.freeze({a:o,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:i,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});e.CURVE=u;const h=(t,e)=>(t+e/s)/e,f={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(t){const{n:e}=u,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-i*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=r,a=BigInt("0x100000000000000000000000000000000"),c=h(s*t,e),f=h(-n*t,e);let l=M(t-c*r-f*o,e),d=M(-c*n-f*s,e);const y=l>a,p=d>a;if(y&&(l=e-l),p&&(d=e-d),l>a||d>a)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:y,k1:l,k2neg:p,k2:d}}},l=32,d=32,y=l+1,p=2*l+1;function g(t){const{a:e,b:r}=u,n=M(t*t),o=M(n*t);return M(o+e*t+r)}const w=u.a===o;class v extends Error{constructor(t){super(t)}}function m(t){if(!(t instanceof b))throw new TypeError("JacobianPoint expected")}class b{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof S))throw new TypeError("JacobianPoint#fromAffine: expected Point");return t.equals(S.ZERO)?b.ZERO:new b(t.x,t.y,i)}static toAffineBatch(t){const e=function(t,e=u.P){const r=new Array(t.length),n=D(t.reduce(((t,n,i)=>n===o?t:(r[i]=t,M(t*n,e))),i),e);return t.reduceRight(((t,n,i)=>n===o?t:(r[i]=M(t*r[i],e),M(t*n,e))),n),r}(t.map((t=>t.z)));return t.map(((t,r)=>t.toAffine(e[r])))}static normalizeZ(t){return b.toAffineBatch(t).map(b.fromAffine)}equals(t){m(t);const{x:e,y:r,z:n}=this,{x:o,y:i,z:s}=t,a=M(n*n),c=M(s*s),u=M(e*c),h=M(o*a),f=M(M(r*s)*c),l=M(M(i*n)*a);return u===h&&f===l}negate(){return new b(this.x,M(-this.y),this.z)}double(){const{x:t,y:e,z:r}=this,n=M(t*t),o=M(e*e),i=M(o*o),u=t+o,h=M(s*(M(u*u)-n-i)),f=M(a*n),l=M(f*f),d=M(l-s*h),y=M(f*(h-d)-c*i),p=M(s*e*r);return new b(d,y,p)}add(t){m(t);const{x:e,y:r,z:n}=this,{x:i,y:a,z:c}=t;if(i===o||a===o)return this;if(e===o||r===o)return t;const u=M(n*n),h=M(c*c),f=M(e*h),l=M(i*u),d=M(M(r*c)*h),y=M(M(a*n)*u),p=M(l-f),g=M(y-d);if(p===o)return g===o?this.double():b.ZERO;const w=M(p*p),v=M(p*w),E=M(f*w),x=M(g*g-v-s*E),S=M(g*(E-x)-d*v),A=M(n*c*p);return new b(x,S,A)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=b.ZERO;if("bigint"==typeof t&&t===o)return e;let r=R(t);if(r===i)return this;if(!w){let t=e,n=this;for(;r>o;)r&i&&(t=t.add(n)),n=n.double(),r>>=i;return t}let{k1neg:n,k1:s,k2neg:a,k2:c}=f.splitScalar(r),u=e,h=e,l=this;for(;s>o||c>o;)s&i&&(u=u.add(l)),c&i&&(h=h.add(l)),l=l.double(),s>>=i,c>>=i;return n&&(u=u.negate()),a&&(h=h.negate()),h=new b(M(h.x*f.beta),h.y,h.z),u.add(h)}precomputeWindow(t){const e=w?128/t+1:256/t+1,r=[];let n=this,o=n;for(let i=0;i<e;i++){o=n,r.push(o);for(let e=1;e<2**(t-1);e++)o=o.add(n),r.push(o);n=o.double()}return r}wNAF(t,e){!e&&this.equals(b.BASE)&&(e=S.BASE);const r=e&&e._WINDOW_SIZE||1;if(256%r)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=e&&x.get(e);n||(n=this.precomputeWindow(r),e&&1!==r&&(n=b.normalizeZ(n),x.set(e,n)));let o=b.ZERO,s=b.BASE;const a=1+(w?128/r:256/r),c=2**(r-1),u=BigInt(2**r-1),h=2**r,f=BigInt(r);for(let e=0;e<a;e++){const r=e*c;let a=Number(t&u);t>>=f,a>c&&(a-=h,t+=i);const l=r,d=r+Math.abs(a)-1,y=e%2!=0,p=a<0;0===a?s=s.add(E(y,n[l])):o=o.add(E(p,n[d]))}return{p:o,f:s}}multiply(t,e){let r,n,o=R(t);if(w){const{k1neg:t,k1:i,k2neg:s,k2:a}=f.splitScalar(o);let{p:c,f:u}=this.wNAF(i,e),{p:h,f:l}=this.wNAF(a,e);c=E(t,c),h=E(s,h),h=new b(M(h.x*f.beta),h.y,h.z),r=c.add(h),n=u.add(l)}else{const{p:t,f:i}=this.wNAF(o,e);r=t,n=i}return b.normalizeZ([r,n])[0]}toAffine(t){const{x:e,y:r,z:n}=this,o=this.equals(b.ZERO);null==t&&(t=o?c:D(n));const s=t,a=M(s*s),u=M(a*s),h=M(e*a),f=M(r*u),l=M(n*s);if(o)return S.ZERO;if(l!==i)throw new Error("invZ was invalid");return new S(h,f)}}function E(t,e){const r=e.negate();return t?r:e}b.BASE=new b(u.Gx,u.Gy,i),b.ZERO=new b(o,i,o);const x=new WeakMap;class S{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,x.delete(this)}hasEvenY(){return this.y%s===o}static fromCompressedHex(t){const e=32===t.length,r=I(e?t:t.subarray(1));if(!V(r))throw new Error("Point is not on curve");let n=function(t){const{P:e}=u,r=BigInt(6),n=BigInt(11),o=BigInt(22),i=BigInt(23),c=BigInt(44),h=BigInt(88),f=t*t*t%e,l=f*f*t%e,d=$(l,a)*l%e,y=$(d,a)*l%e,p=$(y,s)*f%e,g=$(p,n)*p%e,w=$(g,o)*g%e,v=$(w,c)*w%e,m=$(v,h)*v%e,b=$(m,c)*w%e,E=$(b,a)*l%e,x=$(E,i)*g%e,S=$(x,r)*f%e,A=$(S,s);if(A*A%e!==t)throw new Error("Cannot find square root");return A}(g(r));const o=(n&i)===i;e?o&&(n=M(-n)):1==(1&t[0])!==o&&(n=M(-n));const c=new S(r,n);return c.assertValidity(),c}static fromUncompressedHex(t){const e=I(t.subarray(1,l+1)),r=I(t.subarray(l+1,2*l+1)),n=new S(e,r);return n.assertValidity(),n}static fromHex(t){const e=N(t),r=e.length,n=e[0];if(r===l)return this.fromCompressedHex(e);if(r===y&&(2===n||3===n))return this.fromCompressedHex(e);if(r===p&&4===n)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-${y} compressed bytes or ${p} uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return S.BASE.multiply(J(t))}static fromSignature(t,e,r){const{r:n,s:o}=X(e);if(![0,1,2,3].includes(r))throw new Error("Cannot recover: invalid recovery bit");const i=q(N(t)),{n:s}=u,a=2===r||3===r?n+s:n,c=D(a,s),h=M(-i*c,s),f=M(o*c,s),l=1&r?"03":"02",d=S.fromHex(l+H(a)),y=S.BASE.multiplyAndAddUnsafe(d,h,f);if(!y)throw new Error("Cannot recover signature: point at infinify");return y.assertValidity(),y}toRawBytes(t=!1){return j(this.toHex(t))}toHex(t=!1){const e=H(this.x);return t?`${this.hasEvenY()?"02":"03"}${e}`:`04${e}${H(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:r}=this;if(!V(e)||!V(r))throw new Error(t);const n=M(r*r);if(M(n-g(e))!==o)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new S(this.x,M(-this.y))}double(){return b.fromAffine(this).double().toAffine()}add(t){return b.fromAffine(this).add(b.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return b.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){const n=b.fromAffine(this),s=e===o||e===i||this!==S.BASE?n.multiplyUnsafe(e):n.multiply(e),a=b.fromAffine(t).multiplyUnsafe(r),c=s.add(a);return c.equals(b.ZERO)?void 0:c.toAffine()}}function A(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function P(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${O(t)}`);const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:I(r),left:t.subarray(e+2)}}e.Point=S,S.BASE=new S(u.Gx,u.Gy),S.ZERO=new S(o,o);class B{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,r="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${r}: Expected string or Uint8Array`);const n=e?O(t):t;if(128!==n.length)throw new Error(`${r}: Expected 64-byte hex`);return new B(T(n.slice(0,64)),T(n.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r,s:n}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${O(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:r}=P(t.subarray(2)),{data:n,left:o}=P(r);if(o.length)throw new Error(`Invalid signature: left bytes after parsing: ${O(o)}`);return{r:e,s:n}}(e?t:j(t));return new B(r,n)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!F(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!F(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=u.n>>i;return this.s>t}normalizeS(){return this.hasHighS()?new B(this.r,M(-this.s,u.n)):this}toDERRawBytes(){return j(this.toDERHex())}toDERHex(){const t=A(L(this.s)),e=A(L(this.r)),r=t.length/2,n=e.length/2,o=L(r),i=L(n);return`30${L(n+r+4)}02${i}${e}02${o}${t}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return j(this.toCompactHex())}toCompactHex(){return H(this.r)+H(this.s)}}function k(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const o=t[e];r.set(o,n),n+=o.length}return r}e.Signature=B;const _=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function O(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let r=0;r<t.length;r++)e+=_[t[r]];return e}const C=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function H(t){if("bigint"!=typeof t)throw new Error("Expected bigint");if(!(o<=t&&t<C))throw new Error("Expected number 0 <= n < 2^256");return t.toString(16).padStart(64,"0")}function U(t){const e=j(H(t));if(32!==e.length)throw new Error("Error: expected 32 bytes");return e}function L(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function T(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function j(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let r=0;r<e.length;r++){const n=2*r,o=t.slice(n,n+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");e[r]=i}return e}function I(t){return T(O(t))}function N(t){return t instanceof Uint8Array?Uint8Array.from(t):j(t)}function R(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&F(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function M(t,e=u.P){const r=t%e;return r>=o?r:e+r}function $(t,e){const{P:r}=u;let n=t;for(;e-- >o;)n*=n,n%=r;return n}function D(t,e=u.P){if(t===o||e<=o)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=M(t,e),n=e,s=o,a=i,c=i,h=o;for(;r!==o;){const t=n/r,e=n%r,o=s-c*t,i=a-h*t;n=r,r=e,s=c,a=h,c=o,h=i}if(n!==i)throw new Error("invert: does not exist");return M(s,e)}function q(t,e=!1){const r=function(t){const e=8*t.length-8*d,r=I(t);return e>0?r>>BigInt(e):r}(t);if(e)return r;const{n}=u;return r>=n?r-n:r}let K,W;class z{constructor(t,e){if(this.hashLen=t,this.qByteLen=e,"number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(t).fill(1),this.k=new Uint8Array(t).fill(0),this.counter=0}hmac(...t){return e.utils.hmacSha256(this.k,...t)}hmacSync(...t){return W(this.k,...t)}checkSync(){if("function"!=typeof W)throw new v("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){this.incr();let t=0;const e=[];for(;t<this.qByteLen;){this.v=await this.hmac(this.v);const r=this.v.slice();e.push(r),t+=this.v.length}return k(...e)}generateSync(){this.checkSync(),this.incr();let t=0;const e=[];for(;t<this.qByteLen;){this.v=this.hmacSync(this.v);const r=this.v.slice();e.push(r),t+=this.v.length}return k(...e)}}function F(t){return o<t&&t<u.n}function V(t){return o<t&&t<u.P}function G(t,e,r,n=!0){const{n:s}=u,a=q(t,!0);if(!F(a))return;const c=D(a,s),h=S.BASE.multiply(a),f=M(h.x,s);if(f===o)return;const l=M(c*M(e+r*f,s),s);if(l===o)return;let d=new B(f,l),y=(h.x===d.r?0:2)|Number(h.y&i);return n&&d.hasHighS()&&(d=d.normalizeS(),y^=1),{sig:d,recovery:y}}function J(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(t.length!==2*d)throw new Error("Expected 32 bytes of private key");e=T(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(t.length!==d)throw new Error("Expected 32 bytes of private key");e=I(t)}if(!F(e))throw new Error("Expected private key: 0 < key < n");return e}function Z(t){return t instanceof S?(t.assertValidity(),t):S.fromHex(t)}function X(t){if(t instanceof B)return t.assertValidity(),t;try{return B.fromDER(t)}catch(e){return B.fromCompact(t)}}function Y(t){const e=t instanceof Uint8Array,r="string"==typeof t,n=(e||r)&&t.length;return e?n===y||n===p:r?n===2*y||n===2*p:t instanceof S}function Q(t){return I(t.length>l?t.slice(0,l):t)}function tt(t){const e=Q(t),r=M(e,u.n);return et(r<o?e:r)}function et(t){return U(t)}function rt(t,r,n){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const o=N(t),i=J(r),s=[et(i),tt(o)];if(null!=n){!0===n&&(n=e.utils.randomBytes(l));const t=N(n);if(t.length!==l)throw new Error(`sign: Expected ${l} bytes of extra data`);s.push(t)}return{seed:k(...s),m:Q(o),d:i}}function nt(t,e){const{sig:r,recovery:n}=t,{der:o,recovered:i}=Object.assign({canonical:!0,der:!0},e),s=o?r.toDERRawBytes():r.toCompactRawBytes();return i?[s,n]:s}e.getPublicKey=function(t,e=!1){return S.fromPrivateKey(t).toRawBytes(e)},e.recoverPublicKey=function(t,e,r,n=!1){return S.fromSignature(t,e,r).toRawBytes(n)},e.getSharedSecret=function(t,e,r=!1){if(Y(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!Y(e))throw new TypeError("getSharedSecret: second arg must be public key");const n=Z(e);return n.assertValidity(),n.multiply(J(t)).toRawBytes(r)},e.sign=async function(t,e,r={}){const{seed:n,m:o,d:i}=rt(t,e,r.extraEntropy),s=new z(32,d);let a;for(await s.reseed(n);!(a=G(await s.generate(),o,i,r.canonical));)await s.reseed();return nt(a,r)},e.signSync=function(t,e,r={}){const{seed:n,m:o,d:i}=rt(t,e,r.extraEntropy),s=new z(32,d);let a;for(s.reseedSync(n);!(a=G(s.generateSync(),o,i,r.canonical));)s.reseedSync();return nt(a,r)};const ot={strict:!0};function it(t){return M(I(t),u.n)}e.verify=function(t,e,r,n=ot){let o;try{o=X(t),e=N(e)}catch(t){return!1}const{r:i,s}=o;if(n.strict&&o.hasHighS())return!1;const a=q(e);let c;try{c=Z(r)}catch(t){return!1}const{n:h}=u,f=D(s,h),l=M(a*f,h),d=M(i*f,h),y=S.BASE.multiplyAndAddUnsafe(c,l,d);return!!y&&M(y.x,h)===i};class st{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=N(t);if(64!==e.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);const r=I(e.subarray(0,32)),n=I(e.subarray(32,64));return new st(r,n)}assertValidity(){const{r:t,s:e}=this;if(!V(t)||!F(e))throw new Error("Invalid signature")}toHex(){return H(this.r)+H(this.s)}toRawBytes(){return j(this.toHex())}}class at{constructor(t,r,n=e.utils.randomBytes()){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);this.m=N(t);const{x:o,scalar:i}=this.getScalar(J(r));if(this.px=o,this.d=i,this.rand=N(n),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(t){const e=S.fromPrivateKey(t),r=e.hasEvenY()?t:u.n-t;return{point:e,scalar:r,x:e.toRawX()}}initNonce(t,e){return U(t^I(e))}finalizeNonce(t){const e=M(I(t),u.n);if(e===o)throw new Error("sign: Creation of signature failed. k is zero");const{point:r,x:n,scalar:i}=this.getScalar(e);return{R:r,rx:n,k:i}}finalizeSig(t,e,r,n){return new st(t.x,M(e+r*n,u.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m:t,d:r,px:n,rand:o}=this,i=e.utils.taggedHash,s=this.initNonce(r,await i(dt.aux,o)),{R:a,rx:c,k:u}=this.finalizeNonce(await i(dt.nonce,s,n,t)),h=it(await i(dt.challenge,c,n,t)),f=this.finalizeSig(a,u,h,r);return await ht(f,t,n)||this.error(),f}calcSync(){const{m:t,d:r,px:n,rand:o}=this,i=e.utils.taggedHashSync,s=this.initNonce(r,i(dt.aux,o)),{R:a,rx:c,k:u}=this.finalizeNonce(i(dt.nonce,s,n,t)),h=it(i(dt.challenge,c,n,t)),f=this.finalizeSig(a,u,h,r);return ft(f,t,n)||this.error(),f}}function ct(t,e,r){const n=t instanceof st,o=n?t:st.fromHex(t);return n&&o.assertValidity(),{...o,m:N(e),P:Z(r)}}function ut(t,e,r,n){const o=S.BASE.multiplyAndAddUnsafe(e,J(r),M(-n,u.n));return!(!o||!o.hasEvenY()||o.x!==t)}async function ht(t,r,n){try{const{r:o,s:i,m:s,P:a}=ct(t,r,n),c=it(await e.utils.taggedHash(dt.challenge,U(o),a.toRawX(),s));return ut(o,a,i,c)}catch(t){return!1}}function ft(t,r,n){try{const{r:o,s:i,m:s,P:a}=ct(t,r,n),c=it(e.utils.taggedHashSync(dt.challenge,U(o),a.toRawX(),s));return ut(o,a,i,c)}catch(t){if(t instanceof v)throw t;return!1}}e.schnorr={Signature:st,getPublicKey:function(t){return S.fromPrivateKey(t).toRawX()},sign:async function(t,e,r){return new at(t,e,r).calc()},verify:ht,signSync:function(t,e,r){return new at(t,e,r).calcSync()},verifySync:ft},S.BASE._setWindowSize(8);const lt={node:n,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},dt={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},yt={};e.utils={bytesToHex:O,hexToBytes:j,concatBytes:k,mod:M,invert:D,isValidPrivateKey(t){try{return J(t),!0}catch(t){return!1}},_bigintTo32Bytes:U,_normalizePrivateKey:J,hashToPrivateKey:t=>{t=N(t);const e=d+8;if(t.length<e||t.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");return U(M(I(t),u.n-i)+i)},randomBytes:(t=32)=>{if(lt.web)return lt.web.getRandomValues(new Uint8Array(t));if(lt.node){const{randomBytes:e}=lt.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>e.utils.hashToPrivateKey(e.utils.randomBytes(d+8)),precompute(t=8,e=S.BASE){const r=e===S.BASE?e:new S(e.x,e.y);return r._setWindowSize(t),r.multiply(a),r},sha256:async(...t)=>{if(lt.web){const e=await lt.web.subtle.digest("SHA-256",k(...t));return new Uint8Array(e)}if(lt.node){const{createHash:e}=lt.node,r=e("sha256");return t.forEach((t=>r.update(t))),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(lt.web){const r=await lt.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=k(...e),o=await lt.web.subtle.sign("HMAC",r,n);return new Uint8Array(o)}if(lt.node){const{createHmac:r}=lt.node,n=r("sha256",t);return e.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...r)=>{let n=yt[t];if(void 0===n){const r=await e.utils.sha256(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=k(r,r),yt[t]=n}return e.utils.sha256(n,...r)},taggedHashSync:(t,...e)=>{if("function"!=typeof K)throw new v("sha256Sync is undefined, you need to set it");let r=yt[t];if(void 0===r){const e=K(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=k(e,e),yt[t]=r}return K(r,...e)},_JacobianPoint:b},Object.defineProperties(e.utils,{sha256Sync:{configurable:!1,get:()=>K,set(t){K||(K=t)}},hmacSha256Sync:{configurable:!1,get:()=>W,set(t){W||(W=t)}}})},742:(t,e)=>{"use strict";e.byteLength=function(t){var e=a(t),r=e[0],n=e[1];return 3*(r+n)/4-n},e.toByteArray=function(t){var e,r,i=a(t),s=i[0],c=i[1],u=new o(function(t,e,r){return 3*(e+r)/4-r}(0,s,c)),h=0,f=c>0?s-4:s;for(r=0;r<f;r+=4)e=n[t.charCodeAt(r)]<<18|n[t.charCodeAt(r+1)]<<12|n[t.charCodeAt(r+2)]<<6|n[t.charCodeAt(r+3)],u[h++]=e>>16&255,u[h++]=e>>8&255,u[h++]=255&e;return 2===c&&(e=n[t.charCodeAt(r)]<<2|n[t.charCodeAt(r+1)]>>4,u[h++]=255&e),1===c&&(e=n[t.charCodeAt(r)]<<10|n[t.charCodeAt(r+1)]<<4|n[t.charCodeAt(r+2)]>>2,u[h++]=e>>8&255,u[h++]=255&e),u},e.fromByteArray=function(t){for(var e,n=t.length,o=n%3,i=[],s=16383,a=0,u=n-o;a<u;a+=s)i.push(c(t,a,a+s>u?u:a+s));return 1===o?(e=t[n-1],i.push(r[e>>2]+r[e<<4&63]+"==")):2===o&&(e=(t[n-2]<<8)+t[n-1],i.push(r[e>>10]+r[e>>4&63]+r[e<<2&63]+"=")),i.join("")};for(var r=[],n=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0;s<64;++s)r[s]=i[s],n[i.charCodeAt(s)]=s;function a(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");return-1===r&&(r=e),[r,r===e?0:4-r%4]}function c(t,e,n){for(var o,i,s=[],a=e;a<n;a+=3)o=(t[a]<<16&16711680)+(t[a+1]<<8&65280)+(255&t[a+2]),s.push(r[(i=o)>>18&63]+r[i>>12&63]+r[i>>6&63]+r[63&i]);return s.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},764:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.decode=e.encode=e.unescape=e.escape=e.pad=void 0;const n=r(742);function o(t){return`${t}${"=".repeat(4-(t.length%4||4))}`}function i(t){return t.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function s(t){return o(t).replace(/-/g,"+").replace(/_/g,"/")}e.pad=o,e.escape=i,e.unescape=s,e.encode=function(t){return i((0,n.fromByteArray)((new TextEncoder).encode(t)))},e.decode=function(t){return(new TextDecoder).decode((0,n.toByteArray)(o(s(t))))}},803:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.cryptoClients=e.SECP256K1Client=void 0;const n=r(118);Object.defineProperty(e,"SECP256K1Client",{enumerable:!0,get:function(){return n.SECP256K1Client}});const o={ES256K:n.SECP256K1Client};e.cryptoClients=o},118:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.SECP256K1Client=void 0;const n=r(569),o=r(61),i=r(656),s=r(563),a=r(581),c=r(89);i.utils.hmacSha256Sync=(t,...e)=>{const r=n.hmac.create(o.sha256,t);return e.forEach((t=>r.update(t))),r.digest()};class u{static derivePublicKey(t,e=!0){return 66===t.length&&(t=t.slice(0,64)),t.length<64&&(t=t.padStart(64,"0")),(0,c.bytesToHex)(i.getPublicKey(t,e))}static signHash(t,e,r="jose"){if(!t||!e)throw new a.MissingParametersError("a signing input hash and private key are all required");const n=i.signSync(t,e.slice(0,64),{der:!0,canonical:!1});if("der"===r)return(0,c.bytesToHex)(n);if("jose"===r)return(0,s.derToJose)(n,"ES256");throw Error("Invalid signature format")}static loadSignature(t){return(0,s.joseToDer)(t,"ES256")}static verifyHash(t,e,r){if(!t||!e||!r)throw new a.MissingParametersError("a signing input hash, der signature, and public key are all required");return i.verify(e,t,r,{strict:!1})}}e.SECP256K1Client=u,u.algorithmName="ES256K"},674:function(t,e,r){"use strict";var n=this&&this.__awaiter||function(t,e,r,n){return new(r||(r=Promise))((function(o,i){function s(t){try{c(n.next(t))}catch(t){i(t)}}function a(t){try{c(n.throw(t))}catch(t){i(t)}}function c(t){var e;t.done?o(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(s,a)}c((n=n.apply(t,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0}),e.hashSha256Async=e.hashSha256=void 0;const o=r(61);function i(t){return(0,o.sha256)(t)}e.hashSha256=i,e.hashSha256Async=function(t){return n(this,void 0,void 0,(function*(){try{if("undefined"!=typeof crypto&&void 0!==crypto.subtle){const e="string"==typeof t?(new TextEncoder).encode(t):t,r=yield crypto.subtle.digest("SHA-256",e);return new Uint8Array(r)}{const e=r(971);if(!e.createHash)throw new Error("`crypto` module does not contain `createHash`");return Promise.resolve(e.createHash("sha256").update(t).digest())}}catch(e){return console.log(e),console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'),Promise.resolve(i(t))}}))}},891:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.decodeToken=void 0;const n=r(764);e.decodeToken=function(t){if("string"==typeof t){const e=t.split(".");return{header:JSON.parse(n.decode(e[0])),payload:JSON.parse(n.decode(e[1])),signature:e[2]}}if("object"==typeof t){if("string"!=typeof t.payload)throw new Error("Expected token payload to be a base64 or json string");let e=t.payload;"{"!==t.payload[0]&&(e=n.decode(e));const r=[];return t.header.map((t=>{const e=JSON.parse(n.decode(t));r.push(e)})),{header:r,payload:JSON.parse(e),signature:t.signature}}}},563:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.joseToDer=e.derToJose=void 0;const n=r(742),o=r(764);function i(t){return(t/8|0)+(t%8==0?0:1)}const s={ES256:i(256),ES384:i(384),ES512:i(521)};function a(t){const e=s[t];if(e)return e;throw new Error(`Unknown algorithm "${t}"`)}const c=128;function u(t){if(t instanceof Uint8Array)return t;if("string"==typeof t)return(0,n.toByteArray)((0,o.pad)(t));throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array")}function h(t,e,r){let n=0;for(;e+n<r&&0===t[e+n];)++n;return t[e+n]>=c&&--n,n}e.derToJose=function(t,e){const r=u(t),i=a(e),s=i+1,c=r.length;let h=0;if(48!==r[h++])throw new Error('Could not find expected "seq"');let f=r[h++];if(129===f&&(f=r[h++]),c-h<f)throw new Error(`"seq" specified length of "${f}", only "${c-h}" remaining`);if(2!==r[h++])throw new Error('Could not find expected "int" for "r"');const l=r[h++];if(c-h-2<l)throw new Error(`"r" specified length of "${l}", only "${c-h-2}" available`);if(s<l)throw new Error(`"r" specified length of "${l}", max of "${s}" is acceptable`);const d=h;if(h+=l,2!==r[h++])throw new Error('Could not find expected "int" for "s"');const y=r[h++];if(c-h!==y)throw new Error(`"s" specified length of "${y}", expected "${c-h}"`);if(s<y)throw new Error(`"s" specified length of "${y}", max of "${s}" is acceptable`);const p=h;if(h+=y,h!==c)throw new Error(`Expected to consume entire array, but "${c-h}" bytes remain`);const g=i-l,w=i-y,v=new Uint8Array(g+l+w+y);for(h=0;h<g;++h)v[h]=0;v.set(r.subarray(d+Math.max(-g,0),d+l),h),h=i;for(const t=h;h<t+w;++h)v[h]=0;return v.set(r.subarray(p+Math.max(-w,0),p+y),h),(0,o.escape)((0,n.fromByteArray)(v))},e.joseToDer=function(t,e){t=u(t);const r=a(e),n=t.length;if(n!==2*r)throw new TypeError(`"${e}" signatures must be "${2*r}" bytes, saw "${n}"`);const o=h(t,0,r),i=h(t,r,t.length),s=r-o,f=r-i,l=2+s+1+1+f,d=l<c,y=new Uint8Array((d?2:3)+l);let p=0;return y[p++]=48,d?y[p++]=l:(y[p++]=129,y[p++]=255&l),y[p++]=2,y[p++]=s,o<0?(y[p++]=0,y.set(t.subarray(0,r),p),p+=r):(y.set(t.subarray(o,r),p),p+=r-o),y[p++]=2,y[p++]=f,i<0?(y[p++]=0,y.set(t.subarray(r),p)):y.set(t.subarray(r+i),p),y}},581:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.InvalidTokenError=e.MissingParametersError=void 0;class r extends Error{constructor(t){super(),this.name="MissingParametersError",this.message=t||""}}e.MissingParametersError=r;class n extends Error{constructor(t){super(),this.name="InvalidTokenError",this.message=t||""}}e.InvalidTokenError=n},80:function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(e,r);o&&!("get"in o?!e.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,o)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),o=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),o(r(298),e),o(r(523),e),o(r(891),e),o(r(581),e),o(r(803),e)},298:function(t,e,r){"use strict";var n=this&&this.__awaiter||function(t,e,r,n){return new(r||(r=Promise))((function(o,i){function s(t){try{c(n.next(t))}catch(t){i(t)}}function a(t){try{c(n.throw(t))}catch(t){i(t)}}function c(t){var e;t.done?o(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(s,a)}c((n=n.apply(t,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0}),e.TokenSigner=e.createUnsecuredToken=void 0;const o=r(764),i=r(803),s=r(581),a=r(674);function c(t,e){const r=[],n=o.encode(JSON.stringify(e));r.push(n);const i=o.encode(JSON.stringify(t));return r.push(i),r.join(".")}e.createUnsecuredToken=function(t){return c(t,{typ:"JWT",alg:"none"})+"."},e.TokenSigner=class{constructor(t,e){if(!t||!e)throw new s.MissingParametersError("a signing algorithm and private key are required");if("string"!=typeof t)throw new Error("signing algorithm parameter must be a string");if(t=t.toUpperCase(),!i.cryptoClients.hasOwnProperty(t))throw new Error("invalid signing algorithm");this.tokenType="JWT",this.cryptoClient=i.cryptoClients[t],this.rawPrivateKey=e}header(t={}){const e={typ:this.tokenType,alg:this.cryptoClient.algorithmName};return Object.assign({},e,t)}sign(t,e=!1,r={}){const n=this.header(r),o=c(t,n),i=(0,a.hashSha256)(o);return this.createWithSignedHash(t,e,n,o,i)}signAsync(t,e=!1,r={}){return n(this,void 0,void 0,(function*(){const n=this.header(r),o=c(t,n),i=yield(0,a.hashSha256Async)(o);return this.createWithSignedHash(t,e,n,o,i)}))}createWithSignedHash(t,e,r,n,i){const s=this.cryptoClient.signHash(i,this.rawPrivateKey);return e?{header:[o.encode(JSON.stringify(r))],payload:JSON.stringify(t),signature:[s]}:[n,s].join(".")}}},523:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.TokenVerifier=void 0;const n=r(764),o=r(803),i=r(581),s=r(674);e.TokenVerifier=class{constructor(t,e){if(!t||!e)throw new i.MissingParametersError("a signing algorithm and public key are required");if("string"!=typeof t)throw"signing algorithm parameter must be a string";if(t=t.toUpperCase(),!o.cryptoClients.hasOwnProperty(t))throw"invalid signing algorithm";this.tokenType="JWT",this.cryptoClient=o.cryptoClients[t],this.rawPublicKey=e}verify(t){return"string"==typeof t?this.verifyCompact(t,!1):"object"==typeof t&&this.verifyExpanded(t,!1)}verifyAsync(t){return"string"==typeof t?this.verifyCompact(t,!0):"object"==typeof t?this.verifyExpanded(t,!0):Promise.resolve(!1)}verifyCompact(t,e){const r=t.split("."),n=r[0]+"."+r[1],o=t=>{const e=this.cryptoClient.loadSignature(r[2]);return this.cryptoClient.verifyHash(t,e,this.rawPublicKey)};if(e)return(0,s.hashSha256Async)(n).then((t=>o(t)));{const t=(0,s.hashSha256)(n);return o(t)}}verifyExpanded(t,e){const r=[t.header.join("."),n.encode(t.payload)].join(".");let o=!0;const i=e=>(t.signature.map((t=>{const r=this.cryptoClient.loadSignature(t);this.cryptoClient.verifyHash(e,r,this.rawPublicKey)||(o=!1)})),o);if(e)return(0,s.hashSha256Async)(r).then((t=>i(t)));{const t=(0,s.hashSha256)(r);return i(t)}}}},530:function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(e,r);o&&!("get"in o?!e.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,o)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),o=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),o(r(859),e),o(r(497),e),o(r(337),e),o(r(715),e),o(r(248),e)},859:function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(e,r);o&&!("get"in o?!e.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,o)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),o=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),e.getAddress=void 0;const i=r(80);e.getAddress=async t=>{const{message:e,network:r,purposes:n}=t.payload,o=window.BitcoinProvider;if(!o)throw new Error("No Bitcoin Wallet installed");if(!n)throw new Error("Address purposes are required");try{const e=(0,i.createUnsecuredToken)(t.payload),r=await o.connect(e);t.onFinish?.(r)}catch(e){console.error("[Connect] Error during address request",e),t.onCancel?.()}},o(r(252),e)},252:(t,e)=>{"use strict";var r;Object.defineProperty(e,"__esModule",{value:!0}),e.AddressPurposes=void 0,(r=e.AddressPurposes||(e.AddressPurposes={})).PAYMENT="payment",r.ORDINALS="ordinals"},337:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.callWalletPopup=e.CallMethod=void 0;const n=r(80);var o;(o=e.CallMethod||(e.CallMethod={})).SIGN_TRANSACTION="signTransaction",o.GET_ADDRESS="getAddress",e.callWalletPopup=async t=>{const e=window.BitcoinProvider,{method:r}=t.payload;if(!e)throw new Error("No Bitcoin Wallet installed");if(!r)throw new Error("A wallet method is required");const o=(0,n.createUnsecuredToken)(t.payload);try{const r=await e.call(o);t.onFinish?.(r)}catch(e){console.error("[Connect] Error during call request",e),t.onCancel?.()}}},497:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0})},248:function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(e,r);o&&!("get"in o?!e.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,o)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),o=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),e.signMessage=void 0;const i=r(80);e.signMessage=async t=>{const e=window.BitcoinProvider;if(!e)throw new Error("No Bitcoin Wallet installed");try{const r=(0,i.createUnsecuredToken)(t.payload),n=await e.signMessage(r);t.onFinish?.(n)}catch(e){console.error("[Connect] Error during Signing request",e),t.onCancel?.()}},o(r(292),e)},292:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0})},715:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.signTransaction=void 0;const n=r(80);e.signTransaction=async t=>{const{psbtBase64:e,inputsToSign:r}=t.payload,o=window.BitcoinProvider;if(!o)throw new Error("No Bitcoin Wallet installed");if(!e)throw new Error("a value for psbtBase64 representing the tx hash is required");if(!r)throw new Error("an array specifying the inputs to be signed by the wallet is required");try{const e=(0,n.createUnsecuredToken)(t.payload),r=await o.signTransaction(e);t.onFinish?.(r)}catch(e){console.error("[Connect] Error during signPsbt request",e),t.onCancel?.()}}},159:()=>{},971:()=>{}},e={};function r(n){var o=e[n];if(void 0!==o)return o.exports;var i=e[n]={exports:{}};return t[n].call(i.exports,i,i.exports,r),i.exports}(()=>{function t(e){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},t(e)}function e(){"use strict";e=function(){return r};var r={},n=Object.prototype,o=n.hasOwnProperty,i=Object.defineProperty||function(t,e,r){t[e]=r.value},s="function"==typeof Symbol?Symbol:{},a=s.iterator||"@@iterator",c=s.asyncIterator||"@@asyncIterator",u=s.toStringTag||"@@toStringTag";function h(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{h({},"")}catch(t){h=function(t,e,r){return t[e]=r}}function f(t,e,r,n){var o=e&&e.prototype instanceof y?e:y,s=Object.create(o.prototype),a=new k(n||[]);return i(s,"_invoke",{value:S(t,r,a)}),s}function l(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}r.wrap=f;var d={};function y(){}function p(){}function g(){}var w={};h(w,a,(function(){return this}));var v=Object.getPrototypeOf,m=v&&v(v(_([])));m&&m!==n&&o.call(m,a)&&(w=m);var b=g.prototype=y.prototype=Object.create(w);function E(t){["next","throw","return"].forEach((function(e){h(t,e,(function(t){return this._invoke(e,t)}))}))}function x(e,r){function n(i,s,a,c){var u=l(e[i],e,s);if("throw"!==u.type){var h=u.arg,f=h.value;return f&&"object"==t(f)&&o.call(f,"__await")?r.resolve(f.__await).then((function(t){n("next",t,a,c)}),(function(t){n("throw",t,a,c)})):r.resolve(f).then((function(t){h.value=t,a(h)}),(function(t){return n("throw",t,a,c)}))}c(u.arg)}var s;i(this,"_invoke",{value:function(t,e){function o(){return new r((function(r,o){n(t,e,r,o)}))}return s=s?s.then(o,o):o()}})}function S(t,e,r){var n="suspendedStart";return function(o,i){if("executing"===n)throw new Error("Generator is already running");if("completed"===n){if("throw"===o)throw i;return{value:void 0,done:!0}}for(r.method=o,r.arg=i;;){var s=r.delegate;if(s){var a=A(s,r);if(a){if(a===d)continue;return a}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if("suspendedStart"===n)throw n="completed",r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n="executing";var c=l(t,e,r);if("normal"===c.type){if(n=r.done?"completed":"suspendedYield",c.arg===d)continue;return{value:c.arg,done:r.done}}"throw"===c.type&&(n="completed",r.method="throw",r.arg=c.arg)}}}function A(t,e){var r=e.method,n=t.iterator[r];if(void 0===n)return e.delegate=null,"throw"===r&&t.iterator.return&&(e.method="return",e.arg=void 0,A(t,e),"throw"===e.method)||"return"!==r&&(e.method="throw",e.arg=new TypeError("The iterator does not provide a '"+r+"' method")),d;var o=l(n,t.iterator,e.arg);if("throw"===o.type)return e.method="throw",e.arg=o.arg,e.delegate=null,d;var i=o.arg;return i?i.done?(e[t.resultName]=i.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,d):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,d)}function P(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function B(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function k(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(P,this),this.reset(!0)}function _(t){if(t){var e=t[a];if(e)return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,n=function e(){for(;++r<t.length;)if(o.call(t,r))return e.value=t[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return n.next=n}}return{next:O}}function O(){return{value:void 0,done:!0}}return p.prototype=g,i(b,"constructor",{value:g,configurable:!0}),i(g,"constructor",{value:p,configurable:!0}),p.displayName=h(g,u,"GeneratorFunction"),r.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},r.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,g):(t.__proto__=g,h(t,u,"GeneratorFunction")),t.prototype=Object.create(b),t},r.awrap=function(t){return{__await:t}},E(x.prototype),h(x.prototype,c,(function(){return this})),r.AsyncIterator=x,r.async=function(t,e,n,o,i){void 0===i&&(i=Promise);var s=new x(f(t,e,n,o),i);return r.isGeneratorFunction(e)?s:s.next().then((function(t){return t.done?t.value:s.next()}))},E(b),h(b,u,"Generator"),h(b,a,(function(){return this})),h(b,"toString",(function(){return"[object Generator]"})),r.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function t(){for(;r.length;){var n=r.pop();if(n in e)return t.value=n,t.done=!1,t}return t.done=!0,t}},r.values=_,k.prototype={constructor:k,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(B),!t)for(var e in this)"t"===e.charAt(0)&&o.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var e=this;function r(r,n){return s.type="throw",s.arg=t,e.next=r,n&&(e.method="next",e.arg=void 0),!!n}for(var n=this.tryEntries.length-1;n>=0;--n){var i=this.tryEntries[n],s=i.completion;if("root"===i.tryLoc)return r("end");if(i.tryLoc<=this.prev){var a=o.call(i,"catchLoc"),c=o.call(i,"finallyLoc");if(a&&c){if(this.prev<i.catchLoc)return r(i.catchLoc,!0);if(this.prev<i.finallyLoc)return r(i.finallyLoc)}else if(a){if(this.prev<i.catchLoc)return r(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return r(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&o.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var i=n;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var s=i?i.completion:{};return s.type=t,s.arg=e,i?(this.method="next",this.next=i.finallyLoc,d):this.complete(s)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),d},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),B(r),d}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;B(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(t,e,r){return this.delegate={iterator:_(t),resultName:e,nextLoc:r},"next"===this.method&&(this.arg=void 0),d}},r}function n(t,e,r,n,o,i,s){try{var a=t[i](s),c=a.value}catch(t){return void r(t)}a.done?e(c):Promise.resolve(c).then(n,o)}function o(t){return function(){var e=this,r=arguments;return new Promise((function(o,i){var s=t.apply(e,r);function a(t){n(s,o,i,a,c,"next",t)}function c(t){n(s,o,i,a,c,"throw",t)}a(void 0)}))}}var i=r(530).getAddress;function s(){return a.apply(this,arguments)}function a(){return(a=o(e().mark((function t(){var r,n,o,i,s,a,c;return e().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(!window.unisat){t.next=20;break}return t.prev=1,t.next=4,window.unisat.requestAccounts();case 4:if(!(r=t.sent)[0]){t.next=13;break}return t.next=8,fetch("https://b33pb00p-4d7029c0887f.herokuapp.com/wallet/".concat(r[0]));case 8:return n=t.sent,t.next=11,n.json();case 11:if((o=t.sent).imageURLs&&o.imageURLs.length>0)for((i=document.getElementById("asset-link")).innerHTML="",s=["Full color","Monochromatic"],a=0;a<o.imageURLs.length;a++)(c=document.createElement("a")).href=o.imageURLs[a],c.textContent=s[a]?s[a]:"Click here to download asset ".concat(a+1),c.target="_blank",i.appendChild(c);else alert("Unable to verify wallet.");case 13:t.next=18;break;case 15:t.prev=15,t.t0=t.catch(1),console.log("Connect failed",t.t0);case 18:t.next=21;break;case 20:console.log("UniSat Wallet is not installed!");case 21:case"end":return t.stop()}}),t,null,[[1,15]])})))).apply(this,arguments)}function c(){return u.apply(this,arguments)}function u(){return u=o(e().mark((function t(){var r;return e().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return r={payload:{purposes:["payment"],message:"Address for receiving payments",network:{type:"Mainnet"}},onFinish:function(){var t=o(e().mark((function t(r){var n,o,i,s,a,c,u,h;return e().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(!((n=r.addresses.filter((function(t){return"payment"===t.purpose}))).length>0)){t.next=12;break}return o=n[0].address,t.next=5,fetch("https://b33pb00p-4d7029c0887f.herokuapp.com/wallet/".concat(o));case 5:return i=t.sent,t.next=8,i.json();case 8:if((s=t.sent).imageURLs&&s.imageURLs.length>0)for((a=document.getElementById("asset-link")).innerHTML="",c=["Full color","Monochromatic"],u=0;u<s.imageURLs.length;u++)(h=document.createElement("a")).href=s.imageURLs[u],h.textContent=c[u]?c[u]:"Click here to download asset ".concat(u+1),h.target="_blank",a.appendChild(h);else alert("Unable to verify wallet.");t.next=13;break;case 12:console.log("No payment address found");case 13:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}(),onCancel:function(){return console.log("Request canceled")}},t.next=3,i(r);case 3:case"end":return t.stop()}}),t)}))),u.apply(this,arguments)}document.getElementById("connect-wallet").addEventListener("click",o(e().mark((function t(){var r;return e().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if("unisat"!==(r=document.getElementById("wallet-selector").value)){t.next=6;break}return t.next=4,s();case 4:t.next=12;break;case 6:if("sats-connect"!==r){t.next=11;break}return t.next=9,c();case 9:t.next=12;break;case 11:console.log("Unknown wallet type!");case 12:case"end":return t.stop()}}),t)}))))})()})();